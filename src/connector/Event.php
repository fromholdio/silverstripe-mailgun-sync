<?php
namespace DPCNSW\SilverstripeMailgunSync\Connector;
use Mailgun\Mailgun;

/**
 * EventsApiClient bottles up common requests to Mailgun via the mailgun-php API client
 */
class Event extends Base {
	protected $results = array();
	
	/**
	 * @param $event see https://documentation.mailgun.com/en/latest/api-events.html#event-types can also a filter e.g "failed OR rejected"
	 * @param $begin an RFC 2822 formatted date
	 */
	public function pollEvents($begin = NULL, $event = NULL) {
		$client = $this->getClient( $this->getApiKey() );
		
		$api_key = $this->getApiKey();
		$client = Mailgun::create( $api_key );

		$domain = $this->getApiDomain();

		$params = array(
			'ascending'    => 'yes',
			'limit'        =>  10,
		);
		
		if($begin) {
			$params['begin'] = $begin;
		}
		
		if($event) {
			$params['event'] = $event;
		}

		# Make the call to the client.
		$response = $client->events()->get("{$domain}", $params);
		
		$items = $response->getItems();
		if(!empty($items)) {
			$this->results = array_merge( $this->results, $items );
			// recursively retrieve the events based on pagination
			$this->getNextPage($client, $response);
		}
		
		print "Events: " . count($this->results) . "\n";
		
		foreach($this->results as $event) {
			// attempt to store the events
			$mailgun_event = \MailgunEvent::storeEvent($event);
			if(!empty($mailgun_event->ID)) {
				print "Got event: " . $mailgun_event->ID . "\n";
			} else {
				print "Failed to create event\n";
			}
		}
		
	}
	
	/*
	 * TODO: this implements the event polling method discussed here http://mailgun-documentation.readthedocs.io/en/latest/api-events.html#event-polling
			In our system, events are generated by physical hosts and follow different routes to the event storage. Therefore, the order in which they appear in the storage and become retrievable - via the events API - does not always correspond to the order in which they occur. Consequently, this system behavior makes straight forward implementation of event polling miss some events. The page of most recent events returned by the events API may not contain all the events that occurred at that time because some of them could still be on their way to the storage engine. When the events arrive and are eventually indexed, they are inserted into the already retrieved pages which could result in the event being missed if the pages are accessed too early (i.e. before all events for the page are available).

			To ensure that all your events are retrieved and accounted for please implement polling the following way:

			1. Make a request to the events API specifying an ascending time range that begins some time in the past (e.g. half an hour ago);
			2. Retrieve a result page;
			3. Check the timestamp of the last event on the result page. If it is older than some threshold age (e.g. half an hour) then go to step (4), otherwise proceed with step (6);
			4. The result page is trustworthy, use events from the page as you please;
			5. Make a request using the next page URL retrieved with the result page, proceed with step (2);
			6. Discard the result page for it is not trustworthy;
			7. Pause for some time (at least 15 seconds);
			8. Repeat the previous request, and proceed with step (2).
	 */
	private function getNextPage($client, $response) {
		// get the next page of the response
		$response = $client->events()->nextPage($response);
		$items = $response->getItems();
		if(empty($items)) {
			// no more items - nothing to do
			return;
		}
		// add to results
		$this->results = array_merge( $this->results, $items );
		return $this->getNextPage($client, $response);
		
	}
	
}
